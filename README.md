# React-Ts-Best-Practices

Documentation for best practices to use with React with Typescript. Note that this documentation builds off of <a href="https://github.com/seanpmaxwell/Typescript-Best-Practices">Typescript best practices</a>, so we won't mention practices that are already mentioned there. 


<br/>
## The project folder structure

### Project Folders Overview

```
- app
-   public/
-   src/
-     assets/
-     common/
-     components/
-       lg/
-       md/
-       sm/
-     hooks/
-     models/
-     pages/
-     styles/
-     util/
-     App.test.tsx
-     App.ctx.tsx
-     App.tsx
-     index.css
-     index.tsx
-     react-app-env.d.ts
-     reportWebVitals.ts
-   .env
-   .eslintrc.json
-   .gitignore
-   README.md
-   package.json
-   tsconfig.json
```

### Folders Explained (files generated by create-react-app are not listed)
- `public/` generated by create-react-app (holds assets like favicons)
- `src/` generated by react
- `assets/` downloaded assets like images, third-party fonts etc
- `common/` shared miscellaneous items like a `Paths.ts` which holds the paths of all your APIs.
- `components/` custom react components (might not be shared like a navigation bar or shared such as a styled button you used in multiple places)
  - `/lg` single components that take up multiple files
  - `/md` single components that take up one file
  - `/sm` multiple components per file
- `/hooks` custom hooks (i.e. useSetState.ts)
- `/models` files for description your data (i.e. User.ts)
- `/pages` the various pages of your application. NOTE: you should structure your pages folders in the same way as they are navigated to by the user. So if your site is like `my-site.com/home`, `my-site.com/posts/view`, and `my-site.com/post/new` the pages folder should look like:
```
-   Home/
-     index.tsx
-     index.test.tsx
-   Posts/
-     index.tsx
-     index.test.tsx
-     View/
-       index.test.tsx
-       index.tsx
-     New/
-       index.test.tsx
-       index.tsx
```
- `styles/` various shared styles (i.e. Colors.ts)
- `util/` miscellanous shared logic. Could be modules or inventory scripts (see <a href="https://github.com/seanpmaxwell/Typescript-Best-Practices">Typescript best practices</a>).


<br/>
## Basics of Declaring Functional-Components

- Use PascalCase for naming functional-components.
- Use functions for declaring components not classes. Procedural/functional programming is the dominant trend in JavaScript and is much more convenient for making smaller components. Use function declarations (`function`) not arrow functions for making components so that they are hoisted.
- For components declared in the same file, follow a top down approach. That is, declare children components below the parent so that the pattern of programming for both for doing logic and creating elements stays consistent.
- Don't place static values inside functional-components, if you do they'll have to be reinitialized everytime the component state is updated, which could affect performance for large complex applications. Place them at the top of the file under the `// **** Variables **** //` section (see <a href="https://github.com/seanpmaxwell/Typescript-Best-Practices">Typescript best practices</a>).
- If you use TypeScript, always typesafe a functional-component's properties. For large/complex components, create an interface for the props argument (i.e. `IProps`) and place it in the `// **** Types **** //` section of the file (see <a href="https://github.com/seanpmaxwell/Typescript-Best-Practices">Typescript best practices</a>). If you're using JSDoc, you should also typesafe the properties for shared components, but for single using components (like a the file for a page) specifying the types might be overkill. If a jsdoc custom type also gets large/complex, you could also place it in the `Types` section of your file. Both for typescript and jsdoc, you don't need to specify the return type for functional components cause its always JSX.Element. A good way to remember these rules is that whenever another developer needs to use the component you created, your typesafety should reflect that.


## Handling state managment
- State management is done using `useState`, `useContext`, and maybe `redux` if you have it. We'll cover the best practices for all of them.

### useState()
- For small components that only have one or two state values, using `useState` directly is fine, but once a component starts to have large numbers of state values, using a custom hook to handle all the state values as a single object will make your code much more readable and easier to manage. There might be libraries for this or you copy and paste the source for the custom hook <a href="https://github.com/seanpmaxwell/useSetState/blob/main/src/useSetState.ts">here</a>.
- This will make your code more readable cause now all variables that belong to the local state will began with `state`, and you only need one function managing them `useState()`.

### useContext()
- If a state value in a parent component only needs to go down one layer to a child component that exists in the same file, then prop-drilling is fine; `context` or `redux` is probably overkill. 


<br/>
## Misc

#### Conditional Elements

- Don't need to wrap DOM elements in parenthesis for `&&`. Do use parenthesis for ternary-statements though:
```
// DON'T DO
{isLoading && (
  <div>
    <Indicator allPage />
  </div>
)}

// DO
{isLoading && 
  <div>
    <Indicator allPage />
  </div>
}

// DO
{(isError && !!errMsg) ? (
  <div>
    {errMsg}
  </div>
) : (
  <div>
    Foo Bar
  </div>
)}
```

